<html>
<body>
test dupes
test overlapping promos
test condition same as mod id
test dupe conditions

<script type="text/javascript">

// making assumption in the event of a combo purchase, the items are not sharable to other combos
// making assumption that items purchased with promotion can not have more then one promotion applied
// making assumption to apply the most cost effective promotion for the customer
// making assumption that overlaping promotions are intentional or acceptable

// test cart
let cart = [1003,1001,1005,1002,1003,6732,4900,1003,1007];

// test total for whole
let testTotal = 35.36;

// testing taxable item
let testTaxTotal = 16.92;

// new scheme
let newitems = [
	{_id:1,category:'simple',type:'item',items:[1001],name:'eggs',price:2.99,tax:0},
	{_id:2,category:'simple',type:'item',items:[1002],name:'milk',price:3.99,tax:0},
	{_id:3,category:'simple',type:'item',items:[1003],name:'toothbrush',price:1.99,tax:0},
	{_id:4,category:'buy-x-get-y',type:'promo',items:[1003,1003,1003],name:'toothbrushes',price:-1.99,tax:0},
	{_id:5,category:'simple',type:'item',items:[1005],name:'bread',price:3.49,tax:0},
	{_id:6,category:'simple',type:'item',items:[1006],name:'soda',price:5.99,tax:0},
	{_id:7,category:'additional-tax',type:'item',items:[1007],name:'wine',price:15.49,tax:.0925},
	{_id:8,category:'simple',type:'item',items:[1008],name:'apples',price:1.00,tax:0},
	{_id:9,category:'simple',type:'item',items:[6732],name:'chips',price:2.49,tax:0},
	{_id:10,category:'simple',type:'item',items:[4900],name:'salsa',price:3.49,tax:0},
	{_id:11,category:'bundled',type:'promo',items:[6732,4900],name:'chips and salsa combo',price:-.99,tax:0},
	{_id:12,category:'sale',type:'promo',items:[1002],name:'milk sale',price:-1.00,tax:0},

];

console.log(JSON.stringify({_id:1,category:'simple',type:'item',items:[1001],name:'eggs',price:2.99,tax:0}));

// float
var total = 0;
function processCart(){
	// define scoped clone of cart to ensure no erroneous duplication of shared partials in promotions
	let available = cart.slice();
	// for each item in cart
	for (let i = cart.length - 1; i >= 0; i--) {

		try{
			// apply tax and add items price to subtotal
			let item = newitems.find(entry => entry.type === 'item' && entry.items.length === 1 && entry.items[0] === cart[i]);
			total += (item.price * (1+item.tax));
		}catch(err){
			console.log('item code not found');
			continue;
		}

		// filter modifiers to just those relevant to this cart item
		let relevantModifiers = newitems.filter(entry => entry.type === 'promo' && entry.items.length >= 1 && entry.items.includes(cart[i]));
		// sort promotions by cost savings in the event of duplicate/overlapping promos
		relevantModifiers.sort((a, b) => a.price - b.price);

		// for each relevant modifier try to apply modifiers allowing it to fail when unmet
		for(let found of relevantModifiers){
			try{
				// use set to verify met conditions are of unique indexes in cart
				let valid = new Set();
				for (let j = found.items.length - 1; j >= 0; j--) {
				
					// scoped clone of current items promotion availability
					let arr = available.slice();
					
					// get index of condition item _id
					let index = arr.indexOf(found.items[j]);
					// if not the current cart item, and item exists in cart increment count of conditions met
					if(index !== cart[i] && index !== -1){
						// mutate scoped cart arr but maintains index
						delete arr[index];
						// add to valid indexes
						valid.add(index);
						// clone 
						available = arr.slice();

					}
				}
				// verify all nessesary conditions are met
				if(valid.size === found.items.length){
					// log modifier with all conditions validated
					console.log(found);
					// remove this item as it has received modification
					//delete available[cart[i]][i]; // not after removal of remaining arr delete this

					// apply modifier to total
					total+= found.price;
				}
			}catch(err){
				console.log('err');
			}
		}
	}
}

var t0 = performance.now();
processCart();
var t1 = performance.now();
console.log("Call to processCart took " + (t1 - t0) + " milliseconds.");
console.log(Math.round(total*100)/100);
</script>
</body>
</html>