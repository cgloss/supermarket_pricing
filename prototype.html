<html>
<body>
test dupes
test overlapping promos
test condition same as mod id
test dupe conditions

<script type="text/javascript">

// making assumption that in the event of a combo purchase, the items are not sharable in cases of duplicate partials
// that means this needs corrected

// also look at bundeled again, it may not work as written

// if dupes make sure not to give erroneous uplicat combo

// yo you are assuming the same item would not have more then one conditional arguments... like 1002:{}, 1002:{} thats a problem

// HUGE mistake, not accountng for item modifiers where wait no... becasue for a combo to work you would always have to have both... check other requirments though

// assuming we are not allowing doubling use of cart items in savings and instead want to apply the most cost effective modification to cost for the customer

// assuming they may want the ability to create overlaping promotions, to allow this means alternating the item id with conditions

// let items = [
// 	{_id:1001,name:'eggs',price:1.99},
// 	{_id:1002,name:'milk',price:2.99},
// 	{_id:1003,name:'bread',price:3.99},
// 	{_id:1004,name:'toothbrush',price:1.99},
// 	{_id:1005,name:'soda',price:5.99},
// 	{_id:1006,name:'beer',price:9.99},
// 	{_id:1007,name:'apples',price:1.00},
// 	{_id:1008,name:'pears',price:2.00},
// 	{_id:1009,name:'blueberries',price:3.50},
// 	{_id:1010,name:'strawberries',price:4.50},
// 	{_id:1011,name:'yogurt',price:1.00},
// ];

// {item:number,condition:arr<string>,operation:string,apply:number}
// let modifiers = [
// 	// {_id:1,items:[1003],price:-1.00}, // these are allowing for 4 times use of 1002 when it should only allow 2
// 	// {_id:2,items:[],operation:'*',apply:.0925},
// 	// {_id:3,items:[1001],price:-2.00}, // see above
// 	// {_id:4,items:[1003,1002],price:-3.00},
// 	{_id:5,items:[1004,1004],price:-1.99},
// ]
// todo this structure may need changed becasue the ability to overlap...

// setup callable operations, use absolute value for the apply numeric
// let operations = {
//     '-': function(a, b){ return -Math.abs(b); },
//     '*': function(a, b){ return a * b; }
// };

// refactor to resolve this dupeing of modification
let cart = [6732,4900];
// let cart = [1001,1004,1003,1002,1004,1006,1004,1001,1004,1004,6732,4900,1111];
// let cart = [1004,1004,1004,1004];
// let cart = [1006];

// new scheme
let newitems = [
	{_id:0,items:[6732,4900],name:'chips and salsa combo',price:-.99,tax:0},
	{_id:1,items:[1001],name:'eggs',price:1.99,tax:.06},
	{_id:2,items:[1004],name:'toothbrush',price:1.99,tax:.06},
	{_id:3,items:[1004,1004],name:'toothbrushes',price:-1.99,tax:.06},
	{_id:4,items:[1003],name:'bread',price:3.99,tax:.06},
	{_id:5,items:[1002],name:'milk',price:6.99,tax:.06},
	{_id:12,items:[6732,4900],name:'chips and salsa combo',price:-1.99,tax:0},
	{_id:6,items:[1005],name:'soda',price:5.99,tax:.06},
	{_id:7,items:[1006],name:'wine',price:9.99,tax:.0925},
	{_id:8,items:[1007],name:'apples',price:1.00,tax:.06},
	{_id:9,items:[6732],name:'chips',price:2.49,tax:0},
	{_id:10,items:[4900],name:'salsa',price:3.49,tax:0},
	{_id:11,items:[6732,4900],name:'chips and salsa combo',price:-2.99,tax:0},

];

// float
var total = 0;
function processCart(){
	// store available remaining matches to ensure no erroneous duplication of shared partials in combos
	let available;
	// for each item in cart
	for (let i = cart.length - 1; i >= 0; i--) {

		try{
			// apply tax and add items price to subtotal
			let item = newitems.find(entry => entry.items.length === 1 && entry.items[0] === cart[i]);
			total += (item.price * (1+item.tax));
			//console.log('prior subtotal: '+total);
		}catch(err){
			console.log('item code not found');
			continue;
		}

		// filter modifiers to just those relevant to this cart item
		let relevantModifiers = newitems.filter(function(entry){ return entry.items.length > 1 && entry.items.includes(cart[i]); });
		// sort promotions by cost savings in the event of duplicate/overlapping promos
		relevantModifiers.sort((a, b) => a.price - b.price);

		// for each relevant modifier try to apply modifiers allowing it to fail when unmet
		for(let found of relevantModifiers){
			try{
				// use set to verify met conditions are of unique indexes in cart
				let valid = new Set();
				for (let j = found.items.length - 1; j >= 0; j--) {
					// create scoped clone of cart array to remove used indexes from
					let arr = cart.slice();
					// check if same item was purchased and effected by modification rules
					if(available){
						// replace arr with clone of available remaining matches to ensure no erroneous duplication of shared partials in combos
						arr = available.slice();
					}
					
					// get index of condition item _id
					let test = arr.indexOf(found.items[j]);
					// if not the current cart item, and item exists in cart increment count of conditions met
					if(test !== -1){
						// mutate scoped cart arr but maintains index
						delete arr[test];
						// add to valid indexes
						valid.add(test);
						// add to temp store remaining unused items
						available = arr.slice();

					}
				}
				// verify all nessesary conditions are met
				if(valid.size === found.items.length){
					// log modifier with all conditions validated
					console.log(found);
					// remove this item as it has received modification
					//delete available[cart[i]][i]; // not after removal of remaining arr delete this

					// apply modifier to total
					total+= found.price;
				}
			}catch(err){
				console.log('err');
			}
		}
	}
}

var t0 = performance.now();
processCart();
var t1 = performance.now();
console.log("Call to processCart took " + (t1 - t0) + " milliseconds.");
console.log(Math.round(total*100)/100);
</script>
</body>
</html>